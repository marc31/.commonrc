#!/bin/bash

#  ---------------------------------------------------------------------------
#  https://github.com/marc31/bashrc.git
#
#  Description:  This file holds is source both by .bashrc and .zshrc
#                I use it for commun things
#
#  Sections:
#  1.  Environment Configuration
#  2.  Make Terminal Better (remapping defaults and adding functionality)
#  3.  MacOS interaction
#  4.  File and Folder Management
#  6.  Searching
#  7.  Process Management
#  8.  Networking
#  9.  System Operations & Information
#  10. Web Development
#  11. Function
#  12. Reminders & Notes & Exemple
#  ---------------------------------------------------------------------------

#   -------------------------------
#   1. ENVIRONMENT CONFIGURATION
#   -------------------------------

	#	Source private part
	#   ------------------------------------------------------------
		if [ -f $HOME/.privaterc" ]; then source "$HOME/.privaterc"


	#   Set Paths
	#   ------------------------------------------------------------
	    PATH="$PATH:/usr/local/bin/:~/Documents/web/script/freshdrup"
        PATH="$PATH:/Applications/MAMP/Library/bin:~/.composer/vendor/bin"
        PATH="$PATH:/Applications/MAMP/bin/php/php7.0.12/bin"
		PATH="$PATH:$HOME/.yarn/bin"
		PATH="$PATH:/Library/Frameworks/Python.framework/Versions/2.7/bin"
		export PATH

	# 	Init shell var
	#	------------------------------------------------------------
		if [ -n "$ZSH_VERSION" ]; then
		   # assume Zsh
		   export NOWSHELL='zsh'
		elif [ -n "$BASH_VERSION" ]; then
		   export NOWSHELL='bash'
		fi

	# 	Add ItermIntegration
	#	------------------------------------------------------------
		test -e "${HOME}/.iterm2_shell_integration.${NOWSHELL}" && source "${HOME}/.iterm2_shell_integration.${NOWSHELL}"

	# 	Google Cloud SDK.
	#	------------------------------------------------------------
		# The next line updates PATH for the Google Cloud SDK.
		if [ -f "/Applications/google-cloud-sdk/path.${NOWSHELL}.inc" ]; then source "/Applications/google-cloud-sdk/path.${NOWSHELL}.inc"; fi

		# The next line enables shell command completion for gcloud.
		if [ -f "/Applications/google-cloud-sdk/completion.${NOWSHELL}.inc" ]; then source "/Applications/google-cloud-sdk/completion.${NOWSHELL}.inc"; fi

	# 	NVM
	#	------------------------------------------------------------
		export NVM_DIR="$HOME/.nvm"
		[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
		[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
	
	#   Set Default Editor (change 'Nano' to the editor of your choice)
	#   ------------------------------------------------------------
		export EDITOR=/usr/bin/nano
		export EDITORGUI='subl'

	#   Set default blocksize for ls, df, du
	#   from this: http://hints.macworld.com/comment.php?mode=view&cid=24491
	#   ------------------------------------------------------------
		export BLOCKSIZE=1k

	# 	colorize and formatting command line
	# 	You need iTerm and activate 256 color mode in order to work
	# 	http://kevin.colyar.net/wp-content/uploads/2011/01/Preferences.jpg
	#	------------------------------------------------------------
		green='\x1B[0;32m'
		cyan='\x1B[1;36m'
		blue='\x1B[0;34m'
		grey='\x1B[1;30m'
		red='\x1B[0;31m'
		bold='\033[1m'
		normal='\033[0m'

		# Jump a line
		function line () {
		  echo " "
		}

		function say_blue {
		  echo -e "${blue}${bold}$1${normal}"
		}

		function say_red {
		  echo -e "${red}${bold}$1${normal}"
		}

		function say_green {
		  echo -e "${green}${bold}$1${normal}"
		}

		function say_grey {
		  echo -e "${grey}${bold}$1${normal}"
		}
		
		# 	Yes or No question
		#	------------------------------------------------------------
		function askYN () {
		  say_green "${1}"
		  say_green "o|O|y|Y ou n|N|*"
		  read repdrop
		  echo -e "\t"
		  case "$repdrop" in
		    o|O|y|Y)
		      return 0
		    ;;
		    n|N|*)
		      say_red "Abandon"
		      return 1
		    ;;
		  esac
		}

		# 	Ask Something With Choice
		# 		$1     : MESSAGE
		# 		$2     : DEFAULT (AS INDEX IN $choices) IF USER PROVIDES AN EMPTY ANSWER
		# 		$3-n   : CHOICES (WITH UNIQUE LEADING CHARACTER, E.G: "yes" "no" "abort")
		# 		returns: 0, AND SETS $BOTASK_ANSWER TO THE ANSWER'S INDEX WITHIN $choices
		#	------------------------------------------------------------
		function ask_choice () {

		  ## EASE OUR DEVS' LIFE
		  if ! [[ $2 =~ ^-?[0-9]+$ ]]; then
			say_red "'$2' IS NOT AN INTEGER"
			return 1;
		  fi

		  local msg="$1" 
		  local def_choice=$2
		  shift 2
		  local choices=($@)
		  local prompt=""
		  BOTASK_ANSWER="$def_choice"             #XXX: ACCESS TO USER'S CHOICE
		  for c in "$@"; do
		    if [[ "$c" == "${choices[$def_choice]}" ]]; then
		      prompt="${prompt}${bold}[${c:0:1}]${c:1}${normal} "
		    else
		      prompt="${prompt}[${c:0:1}]${c:1} "
		    fi
		  done

		  while true; do
		    say_green "$msg"
		    echo -ne "$prompt> "
		    read ans
		    for (( i=0; i<=${#choices[@]}-1; i++ )); do
		      test -z $ans && return 0            #TDL: PRESSING SPACE (RETURN OK)
		      c=${choices[$i]}
		      if [[ "$ans" == ${c:0:1} ]]; then
		        echo
		        BOTASK_ANSWER=$i && return 0      #XXX: set -e SO RETURN 0
		      fi
		    done
		    say_red "Please choose a valid answer"               ## USER MISTYPED: EMBARRASSMENT
		  done
		}

		# 	check if provided folder name already exists
		# 	no => create it
		#	------------------------------------------------------------
		function chkdir () {
		  if [ ! -d "${1}" ]
		  then
		    say_blue "Creation du répertoire ${1}"
		    mkdir $1
		  fi
		}

		# 	check file
		# 	no => create it
		#	------------------------------------------------------------
		function chkfile () {
			if sudo [ ! -f /usr/lib/tmpfiles.d/lircd.conf ]
			then
				say_blue "Creation du fichier ${1}"
		    	touch $1
		  	fi
		}
		

#   -----------------------------
#   2. MAKE TERMINAL BETTER
#   -----------------------------

	alias cp='cp -iv'                           # Preferred 'cp' implementation v write file et i ask
	alias mv='mv -iv'                           # Preferred 'mv' implementation
	alias mkdir='mkdir -pv'                     # Preferred 'mkdir' implementation S'assurer que  chaque  répertoire  indiqué  existe. Créer   les   répertoires  parents  manquants
	alias ll="ls -FGlah"
	alias path="echo -e ${PATH//:/\\n}"         # path:         Echo all executable Paths
	alias DT='tee ~/Desktop/terminalOut.txt'    # DT:           Pipe content to file on MacOS Desktop ex : ls | DT
	alias DTview='cat ~/Desktop/terminalOut.txt'
	alias edit="$EDITORGUI"

	mcd () { mkdir -p "$1" && cd "$1" ; }        # mcd:          Makes new Dir and jumps inside
	cl () { cd $* && ll ; }						# cd and list


	#   lr:  Full Recursive Directory Listing
	#   ------------------------------------------
		alias lr='ls -R | grep ":$" | sed -e '\''s/:$//'\'' -e '\''s/[^-][^\/]*\//--/g'\'' -e '\''s/^/   /'\'' -e '\''s/-/|/'\'' | less'

	#   mans:   Search manpage given in agument '1' for term given in argument '2' (case insensitive)
	#           displays paginated result with colored search terms and two lines surrounding each hit.
	# 
	#           Example: mans mplayer codec
	#   --------------------------------------------------------------------
	    mans () {
	        man $1 | grep -iC2 --color=always $2 | less
	    }


	# 	cd:  Add historic for cd command
	#      		Example : cd -- show history
	#			  		  cd -3
	# 	acd_func 1.0.5, 10-nov-2004
	# 	petar marinov, http:/geocities.com/h2428, this is public domain
	#   ------------------------------------------
		cd_func () {
		  local x2 adir the_new_dir index
		  local -i cnt

		  # If call like cd -- print history
		  if [[ $1 ==  "--" ]]; then
		    dirs -v
		    return 0
		  fi

		  the_new_dir=$1

		  # If call with cd without option go to home
		  # -z mean empty char
		  [[ -z $the_new_dir ]] && the_new_dir=$HOME

		  # If call with cd -INT with INT a number
		  # affect the_new_dir var to the dir
		  if [[ ${the_new_dir:0:1} == '-' ]]; then
		    # Extract dir N from dirs
		    index=${the_new_dir:1}
		    [[ -z $index ]] && index=1
		    adir=$(dirs +$index)
		    [[ -z $adir ]] && return 1
		    the_new_dir=$adir
		  fi

		  # '~' has to be substituted by ${HOME}
		  [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

		  # Now change to the new dir and add to the top of the stack
		  pushd "${the_new_dir}" > /dev/null
		  [[ $? -ne 0 ]] && return 1
		  the_new_dir=$(pwd)

		  # Trim down everything beyond 11th entry
		  popd -n +11 2>/dev/null 1>/dev/null

		  # Remove any other occurence of this dir, skipping the top of the stack
		  for ((cnt=1; cnt <= 10; cnt++)); do
		    x2=$(dirs +${cnt} 2>/dev/null)
		    [[ $? -ne 0 ]] && return 0
		    [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
		    if [[ "${x2}" == "${the_new_dir}" ]]; then
		      popd -n +$cnt 2>/dev/null 1>/dev/null
		      cnt=cnt-1
		    fi
		  done

		  echo $the_new_dir
		  return 0
		}

		[[ -n "$BASH_VERSION" ]] && alias cd=cd_func
	#   ------------------------------------------



#   -----------------------------
#   3. MacOS Interaction
#   -----------------------------

	trash () { command mv "$@" ~/.Trash ; }     			# trash:        Moves a file to the MacOS trash
	ql () { qlmanage -p "$*" >& /dev/null; }    			# ql:           Opens any file in MacOS Quicklook Preview
	spotlight () { mdfind "kMDItemDisplayName == '$@'wc"; } # Search for a file using MacOS Spotlight's metadata

#   -------------------------------
#   4. FILE AND FOLDER MANAGEMENT
#   -------------------------------

	zipf () { zip -r "$1".zip "$1" ; }          # zipf:         To create a ZIP archive of a folder

	#   extract:  Extract most know archives with one command
	#   ---------------------------------------------------------
	    extract () {
	        if [ -f $1 ] ; then
	          case $1 in
	            *.tar.bz2)   tar xjf $1     ;;
	            *.tar.gz)    tar xzf $1     ;;
	            *.bz2)       bunzip2 $1     ;;
	            *.rar)       unrar e $1     ;;
	            *.gz)        gunzip $1      ;;
	            *.tar)       tar xf $1      ;;
	            *.tbz2)      tar xjf $1     ;;
	            *.tgz)       tar xzf $1     ;;
	            *.zip)       unzip $1       ;;
	            *.Z)         uncompress $1  ;;
	            *.7z)        7z x $1        ;;
	            *)     echo "'$1' cannot be extracted via extract" ;;
	             esac
	         else
	             echo "'$1' is not a valid file"
	         fi
	    }

	#   cdf:  'Cd's to frontmost window of MacOS Finder
	#   ------------------------------------------------------
	    cdf () {
	        currFolderPath=$( /usr/bin/osascript <<EOT
	            tell application "Finder"
	                try
	            set currFolder to (folder of the front window as alias)
	                on error
	            set currFolder to (path to desktop folder as alias)
	                end try
	                POSIX path of currFolder
	            end tell	
EOT
	        )
	        echo "cd to \"$currFolderPath\""
	        cd "$currFolderPath"
	    }


	#	Copy SD Card
	#   ------------------------------------------------------
		cpSD() {
			# 2015-11-28
			# DSK='disk4'
			# Find disk with LInux partition (works for Raspbian)
			export DSK=`diskutil list | grep "Linux" | cut -c 69-73`
			if [ $DSK ]; then
			    askYN "La carte SD est bien sur le disk ${DSK}"
			else
			    say_red "Disk not found"
			    return 1
			fi
			diskutil unmountDisk /dev/$DSK
			say_blue "please wait - This takes some time"
			say_blue "Ctl+T to show progress!"
			time sudo dd if=/dev/r$DSK bs=4m | gzip -9 > ~/Desktop/sd`date +%Y%m%d`.img.gz
		}


#   ---------------------------
#   5. SEARCHING
#   ---------------------------

	alias qfind="find . -name "                 # qfind:    Quickly search for file
	ff () { /usr/bin/find . -name "$@" ; }      # ff:       Find file under the current directory
	ffs () { /usr/bin/find . -name "$@"'*' ; }  # ffs:      Find file whose name starts with a given string
	ffe () { /usr/bin/find . -name '*'"$@" ; }  # ffe:      Find file whose name ends with a given string

	# cf spotlight: Search for a file using MacOS Spotlight's metadata
		
#   ---------------------------
#   6. PROCESS MANAGEMENT
#   ---------------------------

	#   findPid: find out the pid of a specified process
	#   -----------------------------------------------------
	#       Note that the command name can be specified via a regex
	#       E.g. findPid '/d$/' finds pids of all processes with names ending in 'd'
	#       Without the 'sudo' it will only find processes of the current user
	#   -----------------------------------------------------
	    findPid () { ps acx | grep -i $1 | awk {'print $1'} ; }

	#   memHogsTop, memHogsPs:  Find memory hogs
	#   -----------------------------------------------------
	    alias memHogsTop='top -l 1 -o rsize | head -20'
	    alias memHogsPs='ps wwaxm -o pid,stat,vsize,rss,time,command | head -10'

	#   cpuHogs:  Find CPU hogs
	#   -----------------------------------------------------
	    alias cpuHogs='ps wwaxr -o pid,stat,%cpu,time,command | head -10'


	#   my_ps: List processes owned by my user:
	#   ------------------------------------------------------------
	    myPs() { ps $@ -u $USER -o pid,%cpu,%mem,start,time,bsdtime,command ; }

#   ---------------------------
#   7. NETWORKING
#   ---------------------------

	alias myip='whoami ; echo -e \ - Public facing IP Address: ; curl ipecho.net/plain ; echo ; echo -e \ - Internal IP Address: ;  ipconfig getifaddr en0'                  # myip:         Public facing IP Address
	alias netCons='lsof -i'                             # netCons:      Show all open TCP/IP sockets
	alias flushDNS='dscacheutil -flushcache'            # flushDNS:     Flush out the DNS Cache
	alias lsock='sudo /usr/sbin/lsof -i -P'             # lsock:        Display open sockets
	alias lsockU='sudo /usr/sbin/lsof -nP | grep UDP'   # lsockU:       Display only open UDP sockets
	alias lsockT='sudo /usr/sbin/lsof -nP | grep TCP'   # lsockT:       Display only open TCP sockets
	alias ipInfo0='ipconfig getpacket en0'              # ipInfo0:      Get info on connections for en0
	alias ipInfo1='ipconfig getpacket en1'              # ipInfo1:      Get info on connections for en1
	alias openPorts='sudo lsof -i | grep LISTEN'        # openPorts:    All listening connections
	alias showBlocked='sudo ipfw list'                  # showBlocked:  All ipfw rules inc/ blocked IPs


#   ---------------------------------------
#   8. SYSTEMS OPERATIONS & INFORMATION
#   ---------------------------------------

	# 	Python
	#   -----------------------------------------------------------------------------------
		alias py="/usr/local/bin/pythonw"

	#   cleanupDS:  Recursively delete .DS_Store files
	#   -------------------------------------------------------------------
	    alias cleanupDS="find . -type f -name '*.DS_Store' -ls -delete"

	#   finderShowHidden:   Show hidden files in Finder
	#   finderHideHidden:   Hide hidden files in Finder
	#   -------------------------------------------------------------------
	    alias finderShowHidden='defaults write com.apple.finder ShowAllFiles TRUE'
	    alias finderHideHidden='defaults write com.apple.finder ShowAllFiles FALSE'

	#   cleanupLS:  Clean up LaunchServices to remove duplicates in the "Open With" menu
	#   -----------------------------------------------------------------------------------
	    alias cleanupLS="/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user && killall Finder"

#   ---------------------------------------
#   9. WEB DEVELOPMENT
#   ---------------------------------------
	hostsfile='/etc/hosts'
    	alias hosts='sudo ${EDITORGUI} ${hostsfile}'
    	vhostsfile='/Applications/MAMP/conf/apache/extra/httpd-vhosts.conf'
    	alias vhosts='sudo ${EDITORGUI} ${vhostsfile}'
    	vhostssslfile='/Applications/MAMP/conf/apache/extra/httpd-ssl.conf'
    	alias vhostsssl='sudo ${EDITORGUI} ${vhostssslfile}'

	httpHeaders () { /usr/bin/curl -I -L $@ ; }             # httpHeaders:      Grabs headers from web page

	#   httpDebug:  Download a web page and show info on what took time
	#   -----------------------------------------------------------------------------------
    	httpDebug () { /usr/bin/curl $@ -o /dev/null -w "dns: %{time_namelookup} connect: %{time_connect} pretransfer: %{time_pretransfer} starttransfer: %{time_starttransfer} total: %{time_total}\n" ; }


    	wwwdir=/Applications/MAMP/htdocs
	alias cdroot="cd ${wwwdir}"
	alias cdweb="cd ~/Documents/web"

	#	Apache
	#   -----------------------------------------------------------------------------------
		alias aptest="sudo /Applications/MAMP/Library/bin/apachectl configtest"
		alias apstart="sudo /Applications/MAMP/Library/bin/apachectl start"
		alias apstop="sudo /Applications/MAMP/Library/bin/apachectl stop"
		alias aprestart="sudo /Applications/MAMP/Library/bin/apachectl restart"

	#	Mysql 
	#   -----------------------------------------------------------------------------------
		alias mysqlstop="/Applications/MAMP/Library/bin/mysqladmin -u root -proot --socket=/Applications/MAMP/tmp/mysql/mysql.sock shutdown"
		alias mysqlstart="/Applications/MAMP/Library/bin/mysqld_safe --port=3306 --socket=/Applications/MAMP/tmp/mysql/mysql.sock --pid-file=/Applications/MAMP/tmp/mysql/mysql.pid --log-error=/Applications/MAMP/logs/mysql_error_log &"
		alias mysqlcheck="/Applications/MAMP/Library/bin/mysqlcheck --all-databases --check --check-upgrade -u root -proot --socket=/Applications/MAMP/tmp/mysql/mysql.sock"
		alias mysqlrepair="/Applications/MAMP/Library/bin/mysqlcheck --all-databases --repair -u root -proot --socket=/Applications/MAMP/tmp/mysql/mysql.sock"
		alias mysqlrestart="mysqlstop ; mysqlstart"

	#	MAMP LOG 
	#   -----------------------------------------------------------------------------------
		export mamplog="/Applications/MAMP/logs & /Applications/MAMP/Library/logs"
		export apachelog="/Applications/MAMP/logs/apache_error.log"
 		export mysqllog="/Applications/MAMP/logs/mysql_error_log.err"



	# 	Start/stop mysql and apache
	#   -----------------------------------------------------------------------------------
		servstart () {
			apstart 
			mysqlstart
			say_blue "When Server don't start apache say nothing"
			say_blue "See use servlog in teminal"
		} 	
		servstop () {
			apstop
			mysqlstop
			say_blue "When Server don't start apache say nothing"
			say_blue "See use servlog in teminal"
		}
		servrestart () {
			aprestart
			mysqlrestart
		}

		servlog () {
			tail -f ${apachelog} ${mysqllog}
		} 

	# 	Start php serv 
	#   -----------------------------------------------------------------------------------
		alias phps="php -S localhost:8085"


	#   Drupal
	#   -----------------------------------------------------------------------------------
		alias drupalcs="phpcs --colors --standard=Drupal --extensions='php,module,inc,install,test,profile,theme,js,css,info,txt'"
		alias drupalcsbest="phpcs --colors --standard=DrupalPractice --extensions='php,module,inc,install,test,profile,theme,js,css,info,txt'"
		alias drupalcsfix="phpcbf --colors --standard=Drupal --extensions='php,module,inc,install,test,profile,theme,js,css,info,txt'"
		alias drupalcsbestfix="phpcbf --colors --standard=DrupalPractice --extensions='php,module,inc,install,test,profile,theme,js,css,info,txt'"
		
		alias imexdb="~/Documents/web/script/im_ex/./im_ex" # Export Db drupal

	alias chromefix="/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security --user-data-dir=/Users/narcozy/tmp"
	alias chrome="/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome"


#   -------------------------------
#   10. EDITING FILES
#   -------------------------------
	alias commonrc="source ~/.commonrc"
	alias commonrcm="${EDITORGUI} ~/.commonrc"
	alias privatercm="${EDITORGUI} ~/.privaterc"
	alias bashs="source ~/.bashrc"
	alias bashm="${EDITORGUI} ~/.bashrc"
	alias zhss="source ~/.zshrc"
	alias zhsm="${EDITORGUI} ~/.zshrc"

#   -------------------------------
#   11. Function
#   -------------------------------

	# 	Check if file finish with a newline
	#   -----------------------------------------------------------------------------------
		function file_ends_with_newline() {
	  		[[ $(tail -c1 "$1" | wc -l) -gt 0 ]]
		}

	# 	Generate a random password
	#  		$1 = number of characters; defaults to 32
	# 		remove LC_CTYPE in linux this is for mac
	# 		you can remplace $CHAR by "a-zA-Z0-9-_\$\?\@\.\!"
	#   -----------------------------------------------------------------------------------
		function randpass() {
		   cat /dev/urandom | env LC_CTYPE=C tr -cd "a-zA-Z0-9-_\$\?\@\.\!" | head -c ${1:-32}
		}


	#	GENERATE SSH KEY
	#   -----------------------------------------------------------------------------------
		function sshKeyGen() {

			echo "What's the name of the Key (no spaced please) ? "
			read name

			echo "What's the email associated with it? "
			read email

			ssh-keygen -t rsa -f ~/.ssh/rsa_$name -C "$email"

			ssh-add -K ~/.ssh/rsa_$name

			printf "\n" | tee -a ~/.ssh/config
			echo "IdentityFile ~/.ssh/rsa_$name" | tee -a ~/.ssh/config

			pbcopy < ~/.ssh/rsa_$name.pub;

			echo "SSH Key copied in your clipboard";

		}


	#	CREATE VHOST with ssl
	#	--------------------------------------------------------------------------------------
		function addVhostSsl() {

			if [ $1 ]; then
				url=$1
			else
				url=exemple
			fi

			if [ $2 ]; then
				keyname=${2}
			else
				keyname=server
			fi
			

			url0="${1}.local"

			if ! file_ends_with_newline ${vhostssslfile}
			then
			  printf "\n" >> ${vhostssslfile}
			fi
			if grep -Fxq "  ServerName ${url0}" ${vhostssslfile}
			then
			  say_red "L'entrée ${url0} existe déjà$ dans ${vhostssslfile}."
			else
			  echo " " | sudo tee -a ${vhostssslfile}
			  echo "<VirtualHost *:443>" | sudo tee -a ${vhostssslfile}
			  echo "  ServerName $url0" | sudo tee -a ${vhostssslfile}
			  echo '  DocumentRoot "'"${pathtoinstall}/${url}"'"' | sudo tee -a ${vhostssslfile}
			  echo '  ErrorLog  "'"${wwwdir}/${url}/logs/errors.log"'"' | sudo tee -a ${vhostssslfile}
			  echo '  CustomLog  "'"${wwwdir}/${url}/logs/access.log"'" common' | sudo tee -a ${vhostssslfile}
			  echo '  SSLEngine on'
  			  echo '  SSLCertificateFile "'"/Applications/MAMP/conf/apache/${keyname}.crt"'"'
              echo '  SSLCertificateKeyFile "'"/Applications/MAMP/conf/apache/${keyname}.key"'"'
			  echo '  RewriteEngine On' | sudo tee -a ${vhostssslfile}
			  echo '  <Directory "'"${wwwdir}/${url}"'">' | sudo tee -a ${vhostssslfile}
				echo '    AllowOverride All' | sudo tee -a ${vhostssslfile}
				echo '    Options Indexes FollowSymLinks' | sudo tee -a ${vhostssslfile}
				echo '  </Directory>' | sudo tee -a ${vhostssslfile}
			  echo "</VirtualHost>" | sudo tee -a ${vhostssslfile}
			  say_blue "J'ai crée une entrée dans le fichier ${vhostssslfile}"
			fi
		}


	#   GENERATE MAMP SSL
	#   ----------------------------------------------------------------------------------
		function mampSSL() {

			say_blue "use instead https://github.com/loganstellway/self-signed-ssl.git"
			say_blue "/Users/narcozy/Documents/bricolage/web/script/ssl_auto_signed/self-signed-ssl/self-signed-tls"
			
			# if [ $1 ]; then
			# 	url=$1
			# else
			# 	url=exemple
			# fi

			# if [ $2 ]; then
			# 	keyname=${2}
			# else
			# 	keyname=server
			# fi

			# cd ~

			# # generate a private key (will request a password twice)
			# say_blue 'generate a private key (will request a password twice)'
			# openssl genrsa -des3 -out ${keyname}.key 2048

			# # generate certificate signing request (same password as above)
			# say_blue 'generate certificate signing request (same password as above)'
			# openssl req -sha256 -new -key ${keyname}.key -out ${keyname}.csr -config <(
			# cat <<-EOF
			# [req]
			# default_bits = 2048
			# prompt = no
			# default_md = sha256
			# req_extensions = v3_req
			# distinguished_name = dn

			# [dn]
			# C = FR
			# ST = Finisteres
			# L = Brestville
			# O = Ginkgo
			# OU = Development
			# emailAddress = contact@${url}.local
			# CN = ${url}.local

			# [v3_req]
			# authorityKeyIdentifier = keyid,issuer
			# basicConstraints = CA:FALSE
			# keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
			# subjectAltName = @alt_names

			# [ alt_names ]
			# DNS.1 = ${url}.local
			# DNS.2 = www.${url}.local
			# EOF
			# )

			# # generate the certificate
			# say_blue 'generate the certificate'
			# openssl x509 -req -days 365 -in ${keyname}.csr -signkey ${keyname}.key -out ${keyname}.crt

			# # remove the password from the server key
			# say_blue 'remove the password from the server key'
			# cp ${keyname}.key ${keyname}.tmp
			# openssl rsa -in ${keyname}.tmp -out ${keyname}.key

			# # Move the certificate into your MAMP apache configuration folder
			# say_blue 'Move the certificate into your MAMP apache configuration folder'
			# mv ${keyname}.crt /Applications/MAMP/conf/apache
			# mv ${keyname}.key /Applications/MAMP/conf/apache

			# say_blue 'Add to httpd-ssl'
			# addVhostSsl ${url} ${keyname}

			# say_blue 'Restart serv'
			# servrestart
		}


#   ---------------------------------------
#   12. REMINDERS & NOTES
#   ---------------------------------------

	#   remove_disk: spin down unneeded disk
	#   ---------------------------------------
	#   diskutil eject /dev/disk1s3

	#   mounting a removable drive (of type msdos or hfs)
	#   ---------------------------------------
	#   mkdir /Volumes/Foo
	#   ls /dev/disk*   to find out the device to use in the mount command)
	#   mount -t msdos /dev/disk1s1 /Volumes/Foo
	#   mount -t hfs /dev/disk1s1 /Volumes/Foo

	#   Write in file if doesn't exist with sudo right
	#   -------------------------
	#   if sudo [ ! -f /usr/lib/tmpfiles.d/lircd.conf ]; then
	#     sudo bash -c 'cat > /usr/lib/tmpfiles.d/lircd.conf' <<EOF
	#     d /var/run/lirc 0755 root root
	#   EOF
	#   fi

	#   Check char in a file and remove it if exist
	#   -------------------------
	#   if ! grep -Fxq 'MY_CHAR' MY_FILE; then
	#		echo 'Dont Exist; add it'
	#		sudo echo 'MY_CHAR' >> MY_FILE
	#	else
	#		echo 'Exist; Remove It'
	#		# remove line
	#		grep -Fv 'MY_CHAR' MY_FILE > delete.me
	#		sudo mv -f delete.me MY_FILE
	#	fi

	#   Remove every file Or specific file in dir, sub, subdir
	#   -----------------------------
	#   find . -iname '*.bak' -type f -delete
	#   -iname Case sensitive for insensitive use -iname
	#   for test remove -delete
	#   for all file '*.*'
	#    you can try find -iregex '.*\.\(jpg\|gif\|png\|jpeg\)$'
	# 	find . -name '.AppleDouble' -type d -print -exec rm -rv {} +

	# 	The script will terminate after the first line that fails (returns nonzero exit code)
	# 	-----------------------------
	# 	set -e
	# 	cut on error
	#	if [[ $? -ne 0 ]] ; then
    	#		exit 1
	#	fi
	# 
	#	https://stackoverflow.com/questions/1378274/in-a-bash-script-how-can-i-exit-the-entire-script-if-a-certain-condition-occurs
	# 	yell() { echo "$0: $*" >&2; }
	# 	die() { yell "$*"; exit 111; }
	# 	try() { "$@" || die "cannot $*"; }

	# Get path of this file
	# --------------------------
	# 	path_of_this_file=`dirname "$0"`
	# 	path_of_this_file=`( cd "${path_of_this_file}" && pwd )`
